---
title: "Filipino household income"
author: "Xia Yu (62380486)"
date: "`r Sys.Date()`"
output: pdf_document
---

## Data Preparation

```{r load-income, include=FALSE, eval=T,echo=FALSE}
# Loads the income.csv dataset from a zipped file located at zip_path
zip_path <- "../data/datasets.zip"
if (file.exists(zip_path)) {
income_dataset <- read.csv(unz(zip_path, "income.csv"))
} else {
  stop("The zip file does not exist at the given path.")
}

# Extracts two specific columns (Total.Household.Income and Members.with.age.5...17.years.old) from the dataset and renames them to income and children, respectively.
income <- income_dataset$Total.Household.Income
children <- income_dataset$Members.with.age.5...17.years.old
```

### Data Validation And Statistics Summary

```{r summary statistics and missing value checking, include=TRUE, eval=T}
# Print the summary statistics for the income and children variables
skimp   <- data.frame(income, children)|>skim()
print(skimp)
```

### Initial Scatter Plot Data Exploration

```{r Scatter plot, include=TRUE, eval=T,echo=FALSE}
# Scatter plot of income vs. children
plot(children, income/10000, xlab = "Number of Children", ylab = "Household Income (in 10 Thousands)", main = "Household Income Distribution Based on Number of Children")
```

\newpage

## Linear Regression

### Training Set And Testing Set Preparation

```{r training-data-and-testing-data-setup, include=TRUE, eval=T}
# Set a seed for reproducibility and to minimize RAM usage
set.seed(888)

# Combine income and children into a data frame
data <- data.frame(income = income, children = children)

# Split the data into training and test sets
train_ind <- sample(1:nrow(data), size = 0.8 * nrow(data))  # Randomly select 80% of indices for training set
test_ind <- setdiff(1:nrow(data), train_ind)  # Use remaining indices for test set

train_data <- data[train_ind, ]  # Create training data
test_data <- data[test_ind, ]    # Create test data
```

### Model Training

```{r SLR model fiting, include=TRUE, eval=T}
# fit a linear regression model
model <- lm(income ~ children, data = train_data)

# print the summary of the model
summary(model)
```

\newpage

### Model Explanation

3.a What is the specific form of the affine-linear model, i.e. what are b0 and b1?

-   The general form of the affine-linear model is given by $\text{Y} = b_0 + b_1\cdot X$ , where $X$ represents the single feature, children, and the observed quantitative response $Y$ is income, with $b_0$ as the bias term.

-   The specific form of this model is expressed as: $income =b_0 + b_1 \cdot children$

    -   $b_0$ (intercept): Represents the predicted income when the number of children is zero. In this model, $b_0 = 262735$.

    -   $b_1$ (slope): Indicates the change in income for each additional child. In this model, $b_1 = −11256$.

    -   Thus, the model can be expressed as: $\text{income} = 262735 −11256 \cdot \text{children}$

3.b.1 What is the predicted mean income of a household with $𝑛$ children, for $n \in \{0,1,…,8\}$ ?

```{r train_pred, include=TRUE,eval=T}
# Define variables
n <- 0:8  # n is defined as a vector
# coefficients
b_0 <- coef(model)[1]  # b_0 represents intercept
b_1 <- coef(model)[2]  # b_1 represents slope
# predicted mean income of a household with n children
train_pred <- b_0 + b_1 * n # the predicted mean income
print(train_pred)
```

3.b.2 What are the associated 90% prediction intervals?

$\text{Residual Standard Error (RSE)}$

$\tau = t_{1-\frac{\alpha}{2}} \cdot \text{RSE}$

$\text{prediction intervals} = \hat{y} \pm \tau$

$\text{lower bound} = \hat{y} - \tau$

$\text{upper bound} = \hat{y}+\tau$

```{r prediction intervals, include=TRUE,eval=T}
# Compute true mean income for each n from train_data
true_income_mean <- tapply(train_data$income, train_data$children, mean)
print(true_income_mean)

# Get residual standard error from model summary
residual_se <- summary(model)$sigma  # Residual standard error

# Find critical value for 90% prediction interval
alpha <- 0.1
t_crit <- qt(1 - alpha/2, df = summary(model)$df[2])  # Two-tailed t-value
tau <- t_crit * residual_se
# Compute the 90% prediction interval bounds
lower_bound <- train_pred - tau
upper_bound <- train_pred + tau
```

***3.b.3 Summarize all of above information in a table.***

```{r table, include=TRUE, eval=T, echo=FALSE}
# Create a data frame
test_results <- data.frame(
  n = n, 
  train_pred,
  true_income_mean,
  lower_90 = lower_bound, 
  upper_90 = upper_bound
)


# Create a flextable with custom headers
set_flextable_defaults(
    font.size = 8, 
    theme_fun = theme_vanilla,
    padding = 6,
    background.color = "#EFEFEF")
ft_test <- flextable(test_results) |>
  set_header_labels(
    n = "n",
    true_income_mean = "True Mean Income",
    train_pred = "Predicted Mean Income",
    lower_90 = "Lower Bound (90% PI)",
    upper_90 = "Upper Bound (90% PI)"
  )|>
align(align = "center", part = "all") |>
autofit()  # Adjust column sizes automatically

  
# Print the table
ft_test
```

***3.c.1 Using your test set, check how many percent of data points lie within the 90% prediction intervals.***

To check how many data points in the test set fall within the 90% prediction intervals, we need to:

1\. Predict income for test_data`$`children using the model.

2\. Compute the 90% prediction interval for each prediction.

3\. Count the number of test points where test_data`$`income falls inside the interval.

4\. Calculate the percentage of test points that satisfy this condition.

```{r}
# Predict income for the test set
test_pred <- predict(model, newdata = test_data, se.fit = TRUE, interval = "prediction", level = 0.90)

# Extract the predicted values from the result of `predict()`, fit[,1]
predicted_values <- test_pred$fit[, 1]  # The point predictions (mean of the prediction interval)

# Compute prediction interval bounds from fit[,2] and fit[,3]
lower_bound_test <- test_pred$fit[,2]
upper_bound_test <- test_pred$fit[,3]

# Check if test set income values fall within the interval
within_interval <- (test_data$income >= lower_bound_test) & (test_data$income <= upper_bound_test)

# Calculate percentage of points within the interval
percentage_within <- mean(within_interval) * 100 # When mean() is called on this logical vector, the TRUE value is treated as 1 and the FALSE value is treated as 0. mean() then returns a ratio of 1, i.e., how many data points have revenue within the forecast range.

# Print result
cat("Percentage of test points within the 90% prediction interval:", percentage_within, "%\n")
```

***4. Do all steps of part 3. again, but this time you will be predicting log_income = log(income) instead of income.***

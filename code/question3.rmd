

# ---------------------------

## Description

```{r possum-map, echo=FALSE, out.width="70%", fig.align='center'}
  # Load data-set and visualise
  knitr::include_graphics("../images/possum_age_plot.png")

```
## Discription

```{r question3-status, include=F, eval=T}
# created with the help of ChatGPT as this is not a deliverable. 
# dataframe with workflow steps
pdf_workflow <- data.frame(
  Step = c(      "1. initial analysis", 
                 "2. Exploratory Data Analysis", 
                 "3. Initial Feature Selection", 
                 "4. Model Evaluation", 
                 "5. Refinement of Selected Model", 
                 "6. Performance Testing"),

  Process = c(   "Remove irrelevant columns (`case`, `Pop`), encode categorical variables", 
                 "Check missing values, correlation analysis (`cor()`, `ggcorr()`)", 
                 "Use `stepAIC()` (forward selection) to select key predictors", 
                 "Check significance (`summary()`), check multicollinearity (`vif()`)", 
                 "Decide whether to keep/remove non-significant predictors (`hdlngth`)", 
                 "Compute MSE, residual analysis, compare with alternative models"),
  
  Status = c( " Done", 
              " Done but revisitiong", 
              " Done (`belly`, `hdlngth` selected)", 
              " Done (`vif < 5`, no multicollinearity)", 
              " In progress", 
              " Not done yet")
)
ptable_workflow <- flextable(pdf_workflow) |>
  theme_box() |>  # Apply box theme for automatic borders
  set_table_properties(layout = "fixed") |>  # Allow text to wrap
  width(j = 1, width = 2) |>  # Step column (narrow)
  width(j = 2, width = 3) |>  # Process column (text wraps naturally)
  width(j = 3, width = 2) |>  # Status column (smallest)
  bg(part = "header", bg = "#D3D3D3") |>  # Grey background for header row
  bg(i = NULL, j = 1, bg = "#D3D3D3", part = "body") |>  # Grey background for first column
  color(j = 3, color = "blue") |>  # Color status column text blue
  bold(j = 1) |>  # Bold the "Step" column
  align(j = 1, align = "left", part = "all") |>  # Left-align first column
  fontsize(size = 9)  

# status within the group
ptable_workflow


```

```{r}
ptable_workflow
```


## Load Data

```{r load-possums, include=F, eval=F}

# Load and preprocess data-set
# Performed in framework file as agreed 20250313
zip_path <- "../data/datasets.zip"
file.exists(zip_path)
possums <- read.csv(unz(zip_path, "possums.csv"))

```

## EDA - Data Cleaning and  Initial Analysis

```{r possums-EDA-prep, include=T , eval=T}

set.seed(82171165) 
pskim   <- skim(possums) |> select(skim_variable, n_missing)
print(pskim)                           
head(possums)    
summary(possums)

# possums_0 is the working copy of possums
# we will drop case - as this is just a numeric row index
# we will drop Pop - it is redundant as we have site. 
# we will remove outliers of age
# we will relocate age to the last column for ease of analysis 
# we will impute missing data rather than drop na due to the small number of rows
#  and small number of missing values. 
#
possums_0 <- remove_outliers(possums,"age")                 # remove outliers
possums_0 <- subset(possums_0, select = -c(case, Pop))      # drop case and Pop
possums_0 <- mice(possums_0, m=1, method="mean") |> complete() # impute
possums_0 <- possums_0 |> relocate(age, .after = last_col())   # age is last 
names(possums_0)
# visualise age 
ggplot(possums_0, aes(x = age)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
  ggtitle("Possum Ages Distribution (imputed and without outliers)") +
  theme_minimal()

```

```{r possum-data-splitting}

# data-splitting is performed before cleaning predictors 
# to simulate real-world events. 
# 

# possums_1 is the training possum data (with stratification for age)
#
pTrainIdx <- createDataPartition(possums_0$age, p = 0.8, list = FALSE)
possums_1 <- possums_0[pTrainIdx, ]

# pTestDf is the test possum data           (with stratification)
# pValidateDf is the validation possum data (with stratification) 
#
pTempDf     <- possums_0[-pTrainIdx, ]  #not train
pTestIdx    <- createDataPartition(pTempDf$age, p = 0.5, list = FALSE) 
pTestDf     <- pTempDf[pTestIdx, ]   
pValidateDf <- pTempDf[-pTestIdx, ]

cat("\npossums_1:   ", nrow(possums_1), "\npTestDf:     ", nrow(pTestDf), "\nVpValidateDf: ", nrow(pValidateDf),"\n")

```


```{r possum-EDA1, include=T, eval=T}

# a correlation will determine a first pass of the relevant variables to be used
# possums_2 puts age as the last variable to visualise the correlation easily. 
#
possums_2    <- possums_0 |> relocate(age, .after = last_col()) # age is last for ease of analysis 

# pnumerics_2 has only the numeric columns for the coorelation.
#
pnumerics_2  <- possums_2 |> select(where(is.numeric))          # only use numeric columns  
```

```{r get-yaml-params, include=T, eval=T}

# this is part of a process to determine an 
# alternative that may not be necessary. 
# Access pthreshold from YAML params
#
pthreshold   <- NULL                                            # reset
pthreshold   <- params$pthreshold                               # from yaml parameters
if (is.null(pthreshold) || length(pthreshold) == 0) {           # If NULL or empty, assign default
  pthreshold <- 0.2                                             # use default
  message("⚠️ pthreshold set to default: ", pthreshold, " as header value was invalid.")
} else {
  pthreshold <- as.numeric(pthreshold)                          # numeric value
}

cat("pthreshold: ", pthreshold)

```

```{r select-alternative-possum-participants, include=T, eval=T}

# pmatrix   is a correlation matrix
#
pmatrix      <- cor(pnumerics_2, use = "complete.obs")          # compute 

# ppredictors is a list of the correlation values relative to age. 
# ppnames     is a list of the names of the predictors. These predictors have 
#             still have outliers and na values but this is the first pass.
#             rather than remove all outliers/na for all columns, lets see
#             what this results in. We will take these names and clear only
#             these columns and do a second cor() with the columns cleaned up
#             and see how the correlation looks visually to confirm our choices
#
ppredictors  <- pmatrix["age", ]                                # matrix values relative to age 
pfilter1       <- names(ppredictors) != "age"
pfilter2      <- abs(ppredictors) >= pthreshold & names(ppredictors) != "age"  #bool list of participants 
pnnames      <- names(ppredictors[pfilter1])                     # named list of participants.  
pfnames      <- names(ppredictors[pfilter2])                     # named list of participants.  

# possum_2 is now to have the cols cleaned up 
#
for (col in pfnames) {                                          # cleanup outliers and na
  possums_2  <- possums_2 |> drop_na(all_of(col))               # drop na rows of participants
  if (is.numeric(possums_2[[col]])) {
      possums_2 <- remove_outliers(possums_2, col)              # remove outliers for participants
    }
 }
possums_3   <- possums_2 |> mutate(female = ifelse(sex == "f", 1, 0))
pnumerics_3 <- possums_2 |> select(where(is.numeric))          # only use numeric columns

```
\newpage 
```{r possum-scatterplots for age vs. predictors,, include=T, eval=T}

 # scatterplots for each predictor
 # yes aes_string() has been deprecated but necessary here
#
# Create an empty list to store plots
plot_list <- list()

# Generate scatterplots and store them in the list
for (pre in pnnames) {
  p <- ggplot(possums_0, aes_string(x = pre, y = "age")) + #get col by name
        geom_point(alpha = 0.6) +
        geom_smooth(method = "lm", color = "blue", se = FALSE) +
        labs(title = paste("Scatterplot: Age vs", pre),
             x = pre,
             y = "Age") +
        theme_minimal()
  
  plot_list <- append(plot_list, list(p))  # Append each plot to the list
}

# Arrange the plots in a 2-row, 3-column layout
do.call(grid.arrange, c(plot_list, nrow = 4, ncol = 3))
#starting correlation pnumerics_2
#
```
```{r}
ggcorr(pnumerics_2, label = TRUE)                                 # visualise correlation matrix
ggcorr(pnumerics_3, label = TRUE)                                 # visualise correlation matrix

```

```{r possum-step-analysis-2, include=T, eval=T}

# begining stepwise regression techniques to select a suitable predictive model.
# Start with an intercept-only model and direction = "forward"
#

plm_null_2      <- lm(age ~ 1, data = pnumerics_2)  # No predictors only intercept
plm_full_2      <- lm(age ~ ., data = pnumerics_2)  # All available predictor

pstepwise_2frwd <- stepAIC(plm_null_2, 
                          scope = list(lower = plm_null_2, upper = plm_full_2), 
                          direction = "forward", 
                          trace = TRUE)  # Shows step-by-step selection

pstepwise_2bkwd <- stepAIC(plm_null_2, 
                          scope = list(lower = plm_null_2, upper = plm_full_2), 
                          direction = "backward", 
                          trace = TRUE)  # Shows step-by-step selection

pstepwise_2both <- stepAIC(plm_null_2, 
                          scope = list(lower = plm_null_2, upper = plm_full_2), 
                          direction = "both", 
                          trace = TRUE)  # Shows step-by-step selection


step_analysis(pstepwise_2frwd)
step_analysis(pstepwise_2bkwd)
step_analysis(pstepwise_2both)

```

```{r possum-step-analysis-3, include=T, eval=T}

# begining stepwise regression techniques to select a suitable predictive model.
# Start with an intercept-only model and direction = "forward"
#

plm_null_3      <- lm(age ~ 1, data = pnumerics_3)  # No predictors only intercept
plm_full_3      <- lm(age ~ ., data = pnumerics_3)  # All available predictor

pstepwise_3frwd <- stepAIC(plm_null_3, 
                          scope = list(lower = plm_null_3, upper = plm_full_3), 
                          direction = "forward", 
                          trace = TRUE)  # Shows step-by-step selection

pstepwise_3bkwd <- stepAIC(plm_null_3, 
                          scope = list(lower = plm_null_3, upper = plm_full_3), 
                          direction = "backward", 
                          trace = TRUE)  # Shows step-by-step selection

pstepwise_3both <- stepAIC(plm_null_3, 
                          scope = list(lower = plm_null_3, upper = plm_full_3), 
                          direction = "both", 
                          trace = TRUE)  # Shows step-by-step selection


step_analysis(pstepwise_3frwd)
step_analysis(pstepwise_3bkwd)
step_analysis(pstepwise_3both)

```




```{r}
par(mfrow = c(3, 4), mar = c(4, 4, 2, 1)) # 3 models x 4 plots

plot(pstepwise_2frwd)
plot(pstepwise_2bkwd)
plot(pstepwise_2both)

# Predicted vs. Actual plot
ppredictefrwd <- predict(pstepwise_2frwd)
ppredictebkwd <- predict(pstepwise_2bkwd)
ppredicteboth <- predict(pstepwise_2both)
pactuals   <- pnumerics_2$age
par(mfrow = c(3, 1), mar = c(4, 4, 2, 1)) # 3 models x 4 plots
plot(pactuals, ppredictefrwd,
     xlab = "Actual Age",
     ylab = "Predicted forward",
     main = "pstepwise_2frwd Predicted vs Actual ")

plot(pactuals, ppredictebkwd,
     xlab = "Actual Age",
     ylab = "Predicted backward",
     main = "pstepwise_2frwd Predicted vs Actual ")

plot(pactuals, ppredicteboth,
     xlab = "Actual Age",
     ylab = "Predicted both",
     main = "pstepwise_2frwd Predicted vs Actual ")

abline(a = 0, b = 1, col = "red", lwd = 2)  # reference line

```

par(mfrow = c(2, 2))
plot(pstepwise_2)
```


\newpage
## Feature Selection and Model Training



## Model Evaluation

```{r}
# Residuals vs. Leverage plot shows potential high-leverage points, which may be influencing the model too much

# Compute evaluation metrics
```

## Further Exploration

```{r}
# Additional analysis or research questions 
#[204]
```
